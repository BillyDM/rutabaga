#!/usr/bin/env python

#
# this file is basically a super-basic gyp runtime
# i.e. it reads gyp build rules and converts them to waf rules
#
# released as cc0/public domain code, do whatever with it.
#
# hold on to your butts.
#

from __future__ import print_function
import os

top = '..'

def parse_gyp_file(path):
    parsed = None
    with open(path) as f:
        # just going to assume that libuv's gyp is well-formed
        parsed = eval(f.read())

    return parsed

def find_target(tgts, name):
    r = [t for t in tgts if t['target_name'] == name]

    if len(r) == 1:
        return r[0]
    elif not r:
        return None
    else:
        return r

def eval_condition_list(clist, **kwargs):
    ret = {}

    for c in clist:
        cond = None

        try:
            cond = eval(c[0], kwargs)
        except NameError:
            cond = False

        if cond is True:
            defs = c[1]
        else:
            try:
                defs = c[2]
            except IndexError:
                continue

        for d in defs:
            if d not in ret:
                ret[d] = []

            ret[d].extend(defs[d])

    return ret

def eval_condition_list_recursively(clist, **kwargs):
    ret = {}

    while True:
        defs = eval_condition_list(clist, **kwargs)

        for d in defs:
            if d not in ret:
                ret[d] = []

            ret[d].extend(defs[d])

        if 'conditions' in defs:
            clist = defs['conditions']
        else:
            break

    return ret

def build(bld):
    n = bld.path.get_src().find_resource('libuv/uv.gyp')
    gyp = parse_gyp_file(n.abspath())

    t = find_target(gyp['targets'], 'libuv')

    sources = t['sources']
    defines = []

    for clist in (t['conditions'],
            t['direct_dependent_settings']['conditions']):
        r = eval_condition_list_recursively(clist,
                OS=bld.env.DEST_OS,
                library='static_library')

        sources.extend(r.get('sources', []))
        defines.extend(r.get('defines', []))

    sources = ['libuv/' + s for s in sources
            if os.path.splitext(s)[1] in ('.c', '.cc', '.cpp')]

    bld(
        export_includes='libuv/include',
        name='libuv_includes')

    bld.stlib(
        source=sources,
        includes=['libuv/include', 'libuv/src'],
        target='uv',
        name='libuv',
        defines=defines)
